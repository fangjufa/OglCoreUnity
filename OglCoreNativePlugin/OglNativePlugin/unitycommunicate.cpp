#include<Windows.h>
#include"OglWindow.hpp"
#include"Debug.h"
#include"Unity\IUnityGraphics.h"
#include"Unity\IUnityInterface.h"
#include"GLEW\glew.h"
#include"ShaderResource.hpp"
#include<assert.h>
#include"GLContext.h"

using namespace dxlib;

oglWindow	dxWind;
HDC         imageDC;        // the DC to hold our image
int			texture_w;
int			texture_h;
GLuint      textureId;
//GLContext   glContext;
HGLRC		u3dhRC;

GLuint m_VertexShader;
GLuint m_FragmentShader;

//shader程序
GLuint m_Program;

//顶点数组对象
GLuint m_VAO;
//顶点缓存，还要看一下在哪里用
GLuint m_VertexBuffer;
//索引缓存
GLuint m_IndexBuffer;

GLuint kVertexInputPosition = 0;
GLuint kVertexInputTexcoord = 1;

UnityGfxRenderer apiType;

GLContext glContext;

//顶点数据不是以Vector3的形式存储，而是以float的形式存储，这个有点意外。
float* vertexArray;
int*   indexArray;

int vertexLength;
int indicesLength;

//创建Vertex和Fragment shader.

static const char* kGlesVProgTextGLCore = VERTEX_SHADER_SRC();

static const char* kGlesFShaderTextGLCore = FRAGMENT_SHADER_SRC();

static GLuint CompileShader(GLenum type, const char* sourceText)
{
	GLuint ret = glCreateShader(type);
	glShaderSource(ret, 1, &sourceText, NULL);
	glCompileShader(ret);
	if (ret != GL_ZERO)
		Debug::GetInst()->Log("Compile shader success.\r\n");
	else
		Debug::GetInst()->Log("Compile shader failed.Type:%d.\r\n", type);
	return ret;
}

//type specify whether it is a vertex or fragment shader.
static void CreateShader()
{
	//if (apiType == kUnityGfxRendererOpenGLCore)
	//{
		glewExperimental = GL_TRUE;
		GLenum init = glewInit();
		if(init != GLEW_OK)
			Debug::GetInst()->Log("glew初始化错误:%s.", glewGetErrorString(init));
		//GLenum error = glGetError(); // Clean up error generated by glewInit
		//if (error != GL_NO_ERROR)
		//	Debug::GetInst()->Log("Create shader error:%d.", error);

		m_VertexShader = CompileShader(GL_VERTEX_SHADER, kGlesVProgTextGLCore);
		m_FragmentShader = CompileShader(GL_FRAGMENT_SHADER, kGlesFShaderTextGLCore);
	//}

	Debug::GetInst()->Log("Create shader success.\r\n");

	// Link shaders into a program and find uniform locations
	m_Program = glCreateProgram();
	if (m_Program != 0)
		Debug::GetInst()->Log("Shader program not null.\r\n");

	//将变量kVertexInputPosition与shader中的pos变量绑定。
	glBindAttribLocation(m_Program, kVertexInputPosition, "pos");
	glBindAttribLocation(m_Program, kVertexInputTexcoord, "texcoord");
	
	glAttachShader(m_Program, m_VertexShader);
	glAttachShader(m_Program, m_FragmentShader);

	//加上这句话之后，glBindAttribLocation的语句才开始生效。
	glLinkProgram(m_Program);

	GLint status = 0;
	glGetProgramiv(m_Program, GL_LINK_STATUS, &status);
	//Debug::GetInst()->Log("status:%d .\r\n", status);
	if (status != GL_TRUE)
	{
		Debug::GetInst()->Log("status:%d .\r\n", status);
	}

	//m_UniformCoeff = glGetUniformLocation(m_Program, "coeff");
	GLenum error = glGetError();
	Debug::GetInst()->Log("Get shader variable location error:%d.\r\n", error);
}

static void CreateResources()
{
	vertexArray = new float[20]{
		-1.f, -1.f, 0.f,0.f,0.f,
		-1.f, 1.f, 0.f, 0.f,1.f,
		1.f, 1.f, 0.f,  1.f,1.f,
		1.f, -1.f, 0.f ,1.f,0.f };
	//逆时针
	indexArray = new int[6] {0,2,1,3,2,0};
	// Create vertex buffer
	glGenBuffers(1, &m_VertexBuffer);
	glBindBuffer(GL_ARRAY_BUFFER, m_VertexBuffer);
	glBufferData(GL_ARRAY_BUFFER, 20 * sizeof(float), vertexArray, GL_STATIC_DRAW);

	//创建索引缓存
	glGenBuffers(1, &m_IndexBuffer);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_IndexBuffer);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, 6 * sizeof(int), indexArray, GL_STATIC_DRAW);

	//创建VAO。
	glGenVertexArrays(1, &m_VAO);

	assert(glGetError() == GL_NO_ERROR);
	Debug::GetInst()->Log("Create resource success.\r\n");
}

static void Draw()
{
	//这个函数是必须的，不然会没有效果。
	glContext.makeCurrent();
	//if (imageDC == NULL || u3dhRC == NULL || textureId == GL_ZERO)
	//{
	//	Debug::GetInst()->Log("HDC 或者 HRC为空。\n");
	//	return;
	//}
	GLenum glEnum = glGetError();
	if (glEnum != GL_NO_ERROR)
		Debug::GetInst()->Log("First Draw error:%d.\r\n", glEnum);
	/*BOOL wglMakeCur = wglMakeCurrent(imageDC, u3dhRC);
	glEnum = glGetError();
	if (glEnum != GL_NO_ERROR)
		Debug::GetInst()->Log("wglMakeCurrent error:%d.%d\r\n", glEnum,wglMakeCur);*/
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	//glBindTexture(GL_TEXTURE_2D, textureId);

	//设置纹理，或许不需要
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //设置滤波为线性滤波
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);    //线性滤波

	glViewport(0, 0, dxWind.width, dxWind.height);//指明视口
	glEnum = glGetError();
	if (glEnum != GL_NO_ERROR)
		Debug::GetInst()->Log("After viewport error:%d.\r\n", glEnum);


	//设置使用的shader。如果要渲染多个物体并且不同的shader的话，还可以继续加glUseProgram
	glUseProgram(m_Program);
	
	glBindVertexArray(m_VAO);
	//下面的几句话，操作的数组是在glBindBuffer中设置GL_ARRAY_BUFFER设定的。

	glBindBuffer(GL_ARRAY_BUFFER, m_VertexBuffer);
	glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(float) * 5 * 4, vertexArray);
	//开启GPU读取顶点着色器的数据，如果不写这句，GPU是无法读取数据的，因为CPU与GPU之间的通道默认是关闭的。
	glEnableVertexAttribArray(kVertexInputPosition);

	//给shader中传递Position。
	//最后一个参数是指偏移量，因为只有这一个数组，所以偏移量为0.
	glVertexAttribPointer(kVertexInputPosition, 3/*每个顶点属性的组件数量，比如每个顶点由3个float值组成*/, GL_FLOAT, GL_FALSE, 20/*步长，连续两个顶点之间跨越的值*/, (char*)0);

	glEnableVertexAttribArray(kVertexInputTexcoord);
	glVertexAttribPointer(kVertexInputTexcoord, 2, GL_FLOAT, GL_FALSE, 20, (char*)NULL + 12);
	//索引数据
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_IndexBuffer);


	glEnum = glGetError();
	if (glEnum != GL_NO_ERROR)
		Debug::GetInst()->Log("Bind vertex data error:%d.\r\n", glEnum);

	//贴图数据
	GLuint texLocation = glGetUniformLocation(m_Program, "mSampler");
	glUniform1i(texLocation, 0);
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, textureId);

	glEnum = glGetError();
	if (glEnum != GL_NO_ERROR)
		Debug::GetInst()->Log("Bind texture error:%d.\r\n", glEnum);

	//第一个参数：三角形的形态，第二个参数，
	glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

	glDisableVertexAttribArray(kVertexInputPosition);
	glDisableVertexAttribArray(kVertexInputTexcoord);
	glBindTexture(GL_TEXTURE_2D, 0);
	//在绘制完之后清空一下VAO。
	glBindVertexArray(0);

	//SwapBuffers(imageDC);
	glContext.swapBuffer();
}

LRESULT CALLBACK  WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	switch (message)
	{
	case WM_DESTROY:
		//glContext.shutdown();
		Debug::GetInst()->Log("Close window。\r\n");
		PostQuitMessage(0);
		break;
	default:
		//Debug::GetInst()->Log("Default.\r\n");
		return DefWindowProc(hWnd, message, wParam, lParam);
	}
	return 0;
}

///打开窗口并设置窗口渲染的上下文等。
static void SetupWindow()
{
	//打开窗口
	//BOOL result = dxWind.Create(WndProc,GetCurrentWin);
	if (dxWind._hWnd == NULL)
		dxWind.Create(1280,720,WndProc);

	//自主创建绘制上下文，有点问题。
	//PIXELFORMATDESCRIPTOR pfd;
	//imageDC = GetDC(dxWind._hWnd);

	//int nPixelFormat = 2;

	////了解一下该函数的作用
	//SetPixelFormat(imageDC, nPixelFormat, &pfd);
	////创建OGL上下文，并将其设置为当前的窗口。
	//u3dhRC = wglCreateContext(imageDC);

	//BOOL makeCurr = wglMakeCurrent(imageDC, u3dhRC);

	//获取Unity的绘制上下文。
	u3dhRC = wglGetCurrentContext();
	glContext.setup(dxWind._hWnd, GetDC(dxWind._hWnd));
	glContext.shareLists(u3dhRC);
	//wglShareLists()
	

	GLenum err =glGetError();
	Debug::GetInst()->Log("wglMakeCurrent error:%d.\r\n", err);

	//if (imageDC == 0 || u3dhRC == 0)
	//{
	//	Debug::GetInst()->Log("创建DC和Context出现错误。\r\n");
	//}
	//else
	//	Debug::GetInst()->Log("创建DC和Context成功。\r\n");
}

static void UNITY_INTERFACE_API UnityRendering(int eventID)
{
	if (eventID == 100)
	{
		MSG msg;
		while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			//dxlib::Debug::Log("OnRenderEvent_MsgProc():取到了一条消息 msg.hwnd = %d ,hwnd,txwindow._hWnd =%d \r\n", msg.hwnd, txwindow._hWnd);
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
	//创建窗口并创建上下文。
	else if (eventID == 101)
	{
		if (dxWind._hWnd != NULL)
		{
			Debug::GetInst()->Log("Window is existed.");
			return;
		}
		Debug::GetInst()->Log("Open window.\r\n");

		SetupWindow();

		//要先创建上下文，才能创建shader和resources.
		CreateShader();
		CreateResources();
		//可在Update里写，也可以在这里写。
		glClearColor(0,0,1,1);
	}
	//开始每帧渲染
	else if (eventID == 102)
	{
		Draw();
	}
	else if (eventID == 103)
	{
		//Close window
		dxlib::Debug::Log("CloseWindow was called.\r\n");
		dxWind.Close();
		u3dhRC = NULL;
	}
}

///函数签名，一定要正确，不是extern "C" static  xxx  xxx(xxx xx);
extern "C" _declspec(dllexport) void SetTexture(void* textureAddr)
{
	textureId = (GLuint)textureAddr;
}

//Unity 的GL.IssuePluginEvent函数中调用的接口。这里的函数签名必须要带上UnityReneringEvent。
extern "C" UnityRenderingEvent UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API GetRenderEventFunc()
{
	return UnityRendering;
}


extern "C" void	UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API UnityPluginLoad(IUnityInterfaces* unityInterfaces)
{
	Debug::GetInst()->CreatLogFile("LogFile.txt");
	Debug::Log("UnityPluginLoad():加载插件 UnityPlugin  -  Load  \r\n");

	IUnityGraphics* s_Graphics = unityInterfaces->Get<IUnityGraphics>();
	apiType = s_Graphics->GetRenderer();
	if (apiType != kUnityGfxRendererOpenGLCore)
	{
		Debug::Log("Please use opengl core api.");
		return;
	}
	//CreateShader();
	//CreateResources();
}

